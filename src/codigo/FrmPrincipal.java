/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package codigo;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.TreeMap;


/**
 *
 * @author fabri
 */
public class FrmPrincipal extends javax.swing.JFrame {

    /**
     * Creates new form FrmPrincipal
     */
    public FrmPrincipal() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnAnalizar = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtResultado = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtEntrada = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        btnAnalizar.setText("Analizar");
        btnAnalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarActionPerformed(evt);
            }
        });

        txtResultado.setColumns(20);
        txtResultado.setRows(5);
        jScrollPane1.setViewportView(txtResultado);

        txtEntrada.setColumns(20);
        txtEntrada.setRows(5);
        jScrollPane2.setViewportView(txtEntrada);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 495, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnAnalizar, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnAnalizar, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 242, Short.MAX_VALUE)
                .addGap(20, 20, 20))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    /**
    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarActionPerformed
        File archivo = new File("archivo.txt");
        PrintWriter escribir;
        try {
            escribir = new PrintWriter(archivo);
            escribir.print(txtEntrada.getText());
            escribir.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FrmPrincipal.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        try {
            Reader lector = new BufferedReader(new FileReader("archivo.txt"));
            Lexer lexer = new Lexer(lector);
            String resultado = "";
            while (true) {
                //while infinito, hasta que se analice el ultimo texto del txt
                Tokens tokens = lexer.yylex();
                if (tokens == null) {
                    resultado += "Termino";
                    txtResultado.setText(resultado);
                    return;
                }
                switch (tokens) {
                    case ERROR:
                        resultado += "Simbolo no definido\n";
                        break;
                    case IDENTIFICADOR: case ENTERO: case PALABRARESERVADA: case STRING: case CHAR: case OPERADORES: case REAL:
                        resultado += lexer.lexeme + " :Es un " + tokens + "\n";
                        break;
                    default:
                        resultado += "Token " + tokens + "\n";
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FrmPrincipal.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(FrmPrincipal.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnAnalizarActionPerformed
    */
    // ===== 1) Acción del botón: orquestación =====
    //coordina todo el flujo cuando se presiona Analizar.
    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {                                            
        File archivo = new File("archivo.txt");
        try {
            guardarEntrada(archivo, txtEntrada.getText());

            // stats: lexema -> (linea -> conteo)
            Map<String, Map<Integer, Integer>> stats = new TreeMap<>();
            // tipoPorLexema: primer tipo observado por lexema
            Map<String, Tokens> tipoPorLexema = new HashMap<>();
            // errores: línea -> lista de fragmentos inválidos en esa línea
            Map<Integer, java.util.List<String>> erroresPorLinea = new TreeMap<>();

            analizarArchivo(archivo, stats, tipoPorLexema, erroresPorLinea);
            String resumen = construirResumen(stats, tipoPorLexema, erroresPorLinea);
            txtResultado.setText(resumen);

        } catch (Exception ex) {
            txtResultado.setText("Error: " + ex.getMessage());
            Logger.getLogger(FrmPrincipal.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    
    // ===== 2) Guardar entrada (Responsabilidad: IO de entrada) =====
    private void guardarEntrada(File archivo, String contenido) throws FileNotFoundException {
        //Escribe exactamente lo que hay en txtEntrada a archivo.txt.
        try (PrintWriter escribir = new PrintWriter(archivo)) {
            escribir.print(contenido);
        }
    }
    
    // ===== 3) Analizar y acumular (Responsabilidad: dominio/lexer) =====
    private void analizarArchivo(
            File archivo,
            Map<String, Map<Integer, Integer>> stats,
            Map<String, Tokens> tipoPorLexema,
            Map<Integer, java.util.List<String>> erroresPorLinea
    ) throws IOException {

        try (Reader lector = new BufferedReader(new FileReader(archivo))) {
            Lexer lexer = new Lexer(lector);
            Tokens token;

            // Buffer para agrupar errores consecutivos en la misma línea
            StringBuilder errorBuffer = null;
            int errorLine = -1;

            while ((token = lexer.yylex()) != null) {
                int line = lexer.getLine();

                if (token == Tokens.ERROR) {
                    // Abrir o continuar el buffer de error en esta línea
                    if (errorBuffer == null) {
                        errorBuffer = new StringBuilder();
                        errorLine = line;
                    }
                    // Si cambia de línea, cerramos el error anterior
                    if (line != errorLine) {
                        // guardar error anterior
                        erroresPorLinea
                            .computeIfAbsent(errorLine, k -> new ArrayList<>())
                            .add(errorBuffer.toString());
                        // reiniciar para la nueva línea
                        errorBuffer = new StringBuilder();
                        errorLine = line;
                    }
                    // añadir el lexema inválido (carácter o secuencia capturada)
                    errorBuffer.append(lexer.lexeme);
                    continue; // no contamos en stats
                }

                // Si había un error pendiente y llegó un token válido, cerrarlo
                if (errorBuffer != null) {
                    erroresPorLinea
                        .computeIfAbsent(errorLine, k -> new ArrayList<>())
                        .add(errorBuffer.toString());
                    errorBuffer = null;
                    errorLine = -1;
                }

                // ---- Tokens válidos: acumular para el resumen ----
                String lex = lexer.lexeme;

                tipoPorLexema.putIfAbsent(lex, token);
                stats.computeIfAbsent(lex, k -> new TreeMap<>())
                     .merge(line, 1, Integer::sum);
            }

            // EOF: si quedó un error pendiente, guardarlo
            if (errorBuffer != null) {
                erroresPorLinea
                    .computeIfAbsent(errorLine, k -> new ArrayList<>())
                    .add(errorBuffer.toString());
            }
        }
    }

    
    // ===== 4) Construir salida (Responsabilidad: presentación) =====
    private String construirResumen(
            Map<String, Map<Integer, Integer>> stats,
            Map<String, Tokens> tipoPorLexema,
            Map<Integer, java.util.List<String>> erroresPorLinea
    ) {
        StringBuilder out = new StringBuilder();

        // ---- Sección: Tokens válidos ----
        out.append("=== Resumen de Tokens (sin errores) ===\n");
        out.append(String.format("%-24s  %-20s  %s\n",
                "TOKEN (lexema)", "TIPO", "OCURRENCIAS POR LÍNEA"));
        out.append("-------------------------------------------------------------------------------\n");

        for (Map.Entry<String, Map<Integer, Integer>> e : stats.entrySet()) {
            String lexema = e.getKey();
            Tokens tipo   = tipoPorLexema.get(lexema);

            StringBuilder porLineaStr = new StringBuilder();
            boolean first = true;
            for (Map.Entry<Integer, Integer> lc : e.getValue().entrySet()) {
                if (!first) porLineaStr.append(", ");
                first = false;
                porLineaStr.append("l. ").append(lc.getKey()).append(":").append(lc.getValue());
            }

            out.append(String.format("%-24s  %-20s  %s\n",
                    lexema, tipo, porLineaStr.toString()));
        }

        // ---- Sección: Errores léxicos ----
        out.append("\n=== Errores léxicos ===\n");
        if (erroresPorLinea.isEmpty()) {
            out.append("No se encontraron errores léxicos.\n");
        } else {
            // Por cada línea, lista los fragmentos inválidos encontrados en esa línea
            for (Map.Entry<Integer, java.util.List<String>> entry : erroresPorLinea.entrySet()) {
                int line = entry.getKey();
                java.util.List<String> frags = entry.getValue();
                // Unir múltiples fragmentos de la misma línea: "#$%", "@@", etc.
                String unidos = String.join(" | ", frags);
                out.append("l. ").append(line).append(": ").append(unidos).append("\n");
            }
        }

        return out.toString();
    }

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FrmPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FrmPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FrmPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FrmPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FrmPrincipal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAnalizar;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea txtEntrada;
    private javax.swing.JTextArea txtResultado;
    // End of variables declaration//GEN-END:variables
}
